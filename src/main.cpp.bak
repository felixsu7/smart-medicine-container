#include "./alarm.h"
#include "./pins.h"
#include "./preferences.h"
#include "./webserver.h"
#include "./wifi.h"
#include "HardwareSerial.h"
#include "LittleFS.h"
#include "WiFi.h"
#include "clock.h"
#include "esp32-hal-gpio.h"
#include "motor.h"
#include "thirdparty/ST7789v_arduino.h"
#include "thirdparty/XPT2046_Calibrated.h"
#include "utils.h"

static const char* TAG = "main";

DevicePreferences preferences;
Wifi wifi;
Clock rtc;
Alarms alarms;
Webserver webserver;
Motor motor;

ST7789v_arduino tft =
    ST7789v_arduino(TFT_DC, TFT_RST, SPI_MOSI, SPI_SCLK, TFT_CS);
XPT2046_Calibrated touch = XPT2046_Calibrated(TOUCH_CS, TOUCH_IRQ);

void setup() {
  Serial.begin(115200);
  while (!Serial) {}
  assert(Wire.begin());
  Serial.setDebugOutput(true);

  esp_log_level_set("*", ESP_LOG_DEBUG);

  // I2C Address Scanner
  // int devices = 0;
  // for (int addr = 1; addr < 127; addr++) {
  //   char msg[20];
  //   sprintf(msg, "scanning %02X", addr);
  //   Serial.println(msg);
  //   int8_t error = 0;
  //   Wire.beginTransmission(addr);
  //   error = Wire.endTransmission();
  //   if (error == 0) {
  //     char msg[20];
  //     sprintf(msg, "at %02X", addr);
  //     Serial.println(msg);
  //     devices++;
  //   } else {
  //     char msg[20];
  //     sprintf(msg, "error: %d", error);
  //     Serial.println(msg);
  //   }
  // }
  // char msg[20];
  // sprintf(msg, "%d found", devices);
  // Serial.println(msg);

  tft.init(320, 240);
  tft.fillScreen(BLACK);
  tft.setRotation(2);
  touch.begin();
  touch.setRotation(2);

  pinMode(LED_PIN, OUTPUT);
  pinMode(BUZZER_PIN, OUTPUT);
  pinMode(PRI_BUTTON_PIN, INPUT_PULLDOWN);
  pinMode(SEC_BUTTON_PIN, INPUT_PULLDOWN);

  if (!LittleFS.begin()) {
    assert(LittleFS.format());
    esp_restart();
  }
  ESP_LOGI(TAG, "fs size: %ld/%ld\n", LittleFS.usedBytes(),
           LittleFS.totalBytes());

  preferences.setup();
  wifi.setup();
  rtc.setup();
  alarms.setup();
  motor.setup();
  // assert(preferences.save_into_fs() == 0);

  if (WiFi.status() == WL_CONNECTED) {
    assert(webserver.setup(&alarms, &motor, &tft) == 0);
  }

  struct tm now;
  Clock::get(&now);
  alarms.refresh(&now);

  ESP_LOGI(TAG, "alarm size: %d", sizeof(Alarm));
  ESP_LOGI(TAG, "alarm file size: %d", sizeof(Alarms));
  ESP_LOGI(TAG, "alarm log file size: %d", sizeof(AlarmLog));
  ESP_LOGI(TAG, "preferences file stroage size: %d", sizeof(DevicePreferences));
  ESP_LOGI(TAG, "wifi config size: %d", sizeof(WiFiConfig));

  ESP_LOGI(TAG, "took %ldms to boot", millis());
}

void loop() {
  wifi.reconnect_loop();
  alarms.loop();
  motor.loop();

  // static long ring_forecast_tk;
  // if (bounce(&ring_forecast_tk)) {
  //   int idx;
  //   time_t when_ring = alarms.ring_in(&idx);
  //   if (when_ring > 0) {
  //     ESP_LOGD(TAG, "idx %d ringing in %lds", idx, when_ring - time(NULL));
  //   }
  // }

  static long current_ringing_tk;
  if (digitalRead(SEC_BUTTON_PIN) == HIGH) {
    if (bounce(&current_ringing_tk, 200, true)) {
      if (alarms.is_ringing() == -1) {
        ESP_LOGI(TAG, "no currently ringing alarm");
      } else {
        alarms.attend(time(NULL), 0x00, &motor);
      }
    }
  }

  // static long touch_irq_tk;
  // if (touch.tirqTouched()) {
  //   TS_Point p = touch.getPoint();
  //   ESP_LOGD(TAG, "touch irq pin: %d, %d :: %d", p.x, p.y, p.z);
  //   delay(100);
  // }

  static long test_notify_tk;
  if (digitalRead(PRI_BUTTON_PIN) == HIGH) {
    if (bounce(&test_notify_tk, 5000, true)) {
      char message[100];
      static int counter;
      sprintf(message, "Hello world! (%d)", counter++);

      ESP_LOGD(TAG, "sending test notification");

      if (webserver.test_notify(message) == 200) {
        digitalWrite(LED_PIN, HIGH);
        delay(250);
        digitalWrite(LED_PIN, LOW);
      } else {
        digitalWrite(LED_PIN, HIGH);
        delay(1500);
        digitalWrite(LED_PIN, LOW);
      }
    }
  }

  if (alarms.is_ringing() > -1) {
    digitalWrite(BUZZER_PIN, HIGH);
  } else {
    digitalWrite(BUZZER_PIN, LOW);
  }
}
